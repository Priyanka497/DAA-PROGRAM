def bubble_sort(arr):
n = len(arr)
for i in range(n):
for j in range(0, n - i - 1):
if arr[j] > arr[j + 1]:
arr[j], arr[j + 1] = arr[j + 1], arr[j]
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Sorted array:", arr)


def selection_sort(arr):
n = len(arr)
for i in range(n):
min_idx = i
for j in range(i + 1, n):
if arr[j] < arr[min_idx]:
min_idx = j
arr[i], arr[min_idx] = arr[min_idx], arr[i]
arr = [64, 25, 12, 22, 11]
selection_sort(arr)
print("Sorted array:", arr)


def sequential_search(arr, key):
for i in range(len(arr)):
if arr[i] == key:
return i
return -1
arr = [10, 20, 30, 40, 50]
key = 30
result = sequential_search(arr, key)
if result != -1:
print("Element found at index", result)
else:
print("Element not found")


def rabin_karp(text, pattern):
d = 256
q = 101
m = len(pattern)
n = len(text)
p = 0
t = 0
h = 1
for i in range(m - 1):
h = (h * d) % q
for i in range(m):
p = (d * p + ord(pattern[i])) % q
t = (d * t + ord(text[i])) % q
for i in range(n - m + 1):
if p == t:
if text[i:i + m] == pattern:
print("Pattern found at index", i)
if i < n - m:
t = (d * (t - ord(text[i]) * h) + ord(text[i + m])) % q
if t < 0:
t += q
text = "GEEKS FOR GEEKS"
pattern = "GEEK"
rabin_karp(text, pattern)


import itertools
import sys
def travelling_salesman(graph, start):
n = len(graph)
vertices = [i for i in range(n) if i != start]
min_cost = sys.maxsize
for perm in itertools.permutations(vertices):
cost = graph[start][perm[0]]
for i in range(len(perm) - 1):
cost += graph[perm[i]][perm[i + 1]]
cost += graph[perm[-1]][start]
min_cost = min(min_cost, cost)
return min_cost
graph = [
[0, 10, 15, 20],
[10, 0, 35, 25],
[15, 35, 0, 30],
[20, 25, 30, 0]
]
print("Minimum cost:", travelling_salesman(graph, 0))


def knapsack(W, wt, val, n):
dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]
for i in range(n + 1):
for w in range(W + 1):
if i == 0 or w == 0:
    dp[i][w] = 0
elif wt[i - 1] <= w:
dp[i][w] = max(
val[i - 1] + dp[i - 1][w - wt[i - 1]],
dp[i - 1][w]
)
else:
dp[i][w] = dp[i - 1][w]
return dp[n][W]
val = [60, 100, 120]
wt = [10, 20, 30]
W = 50
n = len(val)
print("Maximum value:", knapsack(W, wt, val, n))# Auto detect text files and perform LF normalization
* text=auto


#include <stdio.h>

// Function to merge two subarrays
void merge(int arr[], int left, int mid, int right) {
    int i, j, k;
    int n1 = mid - left + 1;   // size of left subarray
    int n2 = right - mid;      // size of right subarray

    int L[n1], R[n2];   // temporary arrays

    // Copy data to temporary arrays
    for (i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    i = 0;  // initial index of L
    j = 0;  // initial index of R
    k = left;  // initial index of merged array

    // Merge the temp arrays
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy remaining elements of L[]
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy remaining elements of R[]
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// Merge Sort function
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;

        // Divide
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        // Conquer (Merge)
        merge(arr, left, mid, right);
    }
}

// Main function
int main() {
    int arr[] = {38, 27, 43, 3, 9, 82, 10};
    int n = sizeof(arr) / sizeof(arr[0]);

    mergeSort(arr, 0, n - 1);

    printf("Sorted array:\n");
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);

    return 0;
}


#include <iostream>
using namespace std;

int main() {
    int arr[] = {5, 2, 9, 1, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);

    for (int i = 1; i < n; i++) {
        int key = arr[i];   // Current element
        int j = i - 1;

        // Move elements that are greater than key
        // to one position ahead
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }

        arr[j + 1] = key;  // Place key in correct position
    }

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }

    return 0;
}


#include <iostream>
using namespace std;

#define LEFT -1
#define RIGHT 1

// Function to print permutation
void printPermutation(int arr[], int n) {
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;
}

// Function to find largest mobile element
int getMobile(int arr[], int dir[], int n) {
    int mobile = 0;
    int mobile_index = -1;

    for (int i = 0; i < n; i++) {
        int next = i + dir[i];

        if (next >= 0 && next < n && arr[i] > arr[next]) {
            if (arr[i] > mobile) {
                mobile = arr[i];
                mobile_index = i;
            }
        }
    }
    return mobile_index;
}

void johnsonTrotter(int n) {
    int arr[n], dir[n];


#include <iostream>
using namespace std;

int main() {
    int arr[] = {5, 1, 4, 2, 8};
    int n = sizeof(arr) / sizeof(arr[0]);

    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }

    return 0;
}


#include <iostream>
#include <vector>
#include <stack>
using namespace std;

void dfs(int v, vector<vector<int>>& adj, vector<bool>& visited, stack<int>& st) {
    visited[v] = true;

    for (int u : adj[v]) {
        if (!visited[u])
            dfs(u, adj, visited, st);
    }

    st.push(v);  // Push after visiting all neighbors
}

int main() {
    int V = 6;
    vector<vector<int>> adj(V);

    // Adding edges
    adj[5].push_back(2);
    adj[5].push_back(0);
    adj[4].push_back(0);
    adj[4].push_back(1);
    adj[2].push_back(3);
    adj[3].push_back(1);

    vector<bool> visited(V, false);
    stack<int> st;

    for (int i = 0; i < V; i++) {
        if (!visited[i])
            dfs(i, adj, visited, st);
    }

    cout << "Topological Sort: ";
    while (!st.empty()) {
        cout << st.top() << " ";
        st.pop();
    }

    return 0;
}


